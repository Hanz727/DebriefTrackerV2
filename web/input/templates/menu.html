<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='img/logo2.png') }}">
    <title>CVIC MENU</title>

    <style>
        @import url('static/css/color-palette.css');
        @import url('static/css/cvic.css');

        .bda-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(230px, 1fr));
            gap: 10px;
        }

        .bda-card-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }

        .bda-card-link:hover {
            transform: translateY(-2px);
            text-decoration: none;
            color: inherit;
        }

        .bda-card-link:hover .bda-card {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-color: #666;
        }

        .bda-card {
            background: #1f1f1f;
            border: 1px solid #4f545c;
            padding: 15px;
            cursor: pointer;
        }

        .bda-weapon {
            text-transform: uppercase;
            font-weight: bold;
            font-size: var(--font-size-md);
            padding-bottom: 2px;
            white-space: nowrap;
        }

        .bda-target {
            font-size: var(--font-size-sm);
            padding-bottom: 7px;
            white-space: nowrap;
        }

        .bda-id-info {
            font-size: var(--font-size-md);
            text-transform: uppercase;
            white-space: nowrap;
            display: flex;
            justify-content: space-between;
            padding-top: 3px;
        }

        .bda-result {
            font-size: var(--font-size-md);
            white-space: nowrap;
            font-weight: bolder;
        }

        .bda-img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            background: #121212;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            margin-top: 5px;
            border: 1px solid #4f545c;
            text-align: center;
        }

        .bda-img.loading {
            opacity: 0.7;
        }

        .bda-img.loaded {
            opacity: 1;
        }

        .bda-footer-date {
            text-align: right;
            font-size: var(--font-size-sm);
        }

        .presentation-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            border: 1px solid #4f545c;
            background: #121212;
        }

        .presentation-container iframe {
            border: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 1px solid #4f545c;
            background: #121212;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .map-img {
            transform-origin: 0 0;
            width: 100%;
            height: auto;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
            will-change: transform;
        }

        .map-symbols {
            transform-origin: 0 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }

        .map-symbol {
            position: absolute;
            width: 36px;
            height: 36px;
            transition: none;
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.8));
            pointer-events: auto;
            cursor: pointer;
            z-index: 6;
        }

        .map-symbol:hover {
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));
            transform: translate(-50%, -50%) scale(1.2);
        }

        .map-symbol.collision {
            filter: grayscale(100%) brightness(1.0) drop-shadow(0 0 2px rgba(160, 160, 160, 0.8));
            opacity: 1;
        }

        .map-symbol.package {
            filter: brightness(0.7) saturate(2) contrast(1.1);
            opacity: 1;
        }

        .map-symbol.hidden {
            display: None !important;
        }
        .map-ring.hidden {
            display: None !important;
        }
        .map-symbol.collision:hover {
            filter: grayscale(100%) brightness(1.2) drop-shadow(0 0 4px rgba(180, 180, 180, 0.8));
            transform: translate(-50%, -50%) scale(1.2);
        }

        .map-symbol.collision-no-report {
            filter: grayscale(100%) brightness(0.3) drop-shadow(0 0 2px rgba(80, 80, 80, 0.8));
            opacity: 1;
        }

        .map-symbol.collision-no-report:hover {
            filter: grayscale(100%) brightness(0.5) drop-shadow(0 0 4px rgba(100, 100, 100, 0.8));
            transform: translate(-50%, -50%) scale(1.2);
        }

        .map-symbol.clickable {
            cursor: pointer;
        }

        .map-symbol.clickable:hover {
            filter: drop-shadow(0 0 6px rgba(100, 200, 255, 0.9));
            transform: translate(-50%, -50%) scale(1.3);
        }

        .map-symbol.collision.clickable:hover {
            filter: grayscale(100%) brightness(1.2) drop-shadow(0 0 6px rgba(100, 200, 255, 0.9));
            transform: translate(-50%, -50%) scale(1.3);
        }

        .map-symbol.destroyed-no-report {
            filter: brightness(0.4) saturate(0.6);
            opacity: 1;
        }

        .map-symbol.destroyed-no-report:hover {
            filter: brightness(0.6) saturate(0.8) drop-shadow(0 0 4px rgba(120, 120, 120, 0.8));
            transform: translate(-50%, -50%) scale(1.2);
        }

        .map-ring.collision {
            border-color: #ff6b6b;
        }

        .map-ring {
            aspect-ratio: 1;
            position: absolute;
            border: 1px solid #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: none;
            pointer-events: none;
            opacity: 0.7;
            z-index: 4;
        }

        .map-ring.blue {
            border: 2px solid rgb(51, 98, 255) !important;
        }

        .map-symbol-label {
            position: absolute;
            background: rgba(31, 31, 31, 0.95);
            border: 1px solid #4f545c;
            color: white;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: bold;
            white-space: nowrap;
            pointer-events: none;
            z-index: 7;
            border-radius: 2px;
            text-transform: uppercase;
            font-family: monospace;
            transform-origin: top left;
        }

        .map-symbol-label.hidden {
            display: none !important;
        }

        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .fullscreen-btn {
            width: 40px;
            height: 40px;
            background: rgba(31, 31, 31, 0.9);
            border: 1px solid #4f545c;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            user-select: none;
        }

        .fullscreen-btn:hover {
            background: rgba(79, 84, 92, 0.9);
        }

        .fullscreen-btn:active {
            background: rgba(100, 100, 100, 0.9);
        }

        .map-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-height: none;
            z-index: 1000;
            border: none;
        }

        .map-container.fullscreen .map-img {
            width: 100%;
            height: auto;
            object-fit: fill;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(31, 31, 31, 0.9);
            border: 1px solid #4f545c;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            user-select: none;
        }

        .zoom-btn:hover {
            background: rgba(79, 84, 92, 0.9);
        }

        .zoom-btn:active {
            background: rgba(100, 100, 100, 0.9);
        }

        .zoom-level {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(31, 31, 31, 0.9);
            border: 1px solid #4f545c;
            color: white;
            padding: 5px 10px;
            font-size: 12px;
            font-family: monospace;
            z-index: 10;
        }

        .symbol-tooltip {
            position: absolute;
            background: rgba(31, 31, 31, 0.95);
            border: 1px solid #4f545c;
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 15;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease;
            min-width: 120px;
        }

        .tooltip-comment {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .tooltip-comment-small {
            margin-bottom: 4px;
        }

        .tooltip-coords {
            font-size: 11px;
            color: #a0a0a0;
            line-height: 1.3;
        }

        .symbol-tooltip.show {
            opacity: 1;
        }

        .map-selector {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .map-selector-btn {
            width: 100%;
            background: #1f1f1f;
            border: 1px solid #4f545c;
            color: white;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            min-width: 140px;
        }

        .map-selector-btn:hover {
            background: rgba(185, 187, 190, 0.15);
            border-color: #666;
        }

        .map-selector-btn.active {
            background: var(--color-primary);
            border-color: #718096;
            color: white;
        }

        .map-selector-btn:active {
            background: #2d3748;
        }

        .strategic-filters {
            margin-top: 20px;
            background: #1f1f1f;
            border: 1px solid #4f545c;
            padding: 20px;
        }

        .filter-title {
            color: white;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .filter-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 480px) {
            .filter-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px 12px;
            background: #2a2a2a;
            border: 1px solid #4f545c;
            justify-content: center;
        }

        .filter-checkbox:hover {
            background: rgba(185, 187, 190, 0.15);
            border-color: #666;
        }

        .filter-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #4a5568;
        }

        .filter-checkbox input[type="checkbox"]:checked + span {
            color: #90cdf4;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: #2a2a2a;
            border: 1px solid #4f545c;
            color: white;
            padding: 8px 16px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
        }

        .filter-btn:hover {
            background: rgba(185, 187, 190, 0.15);
            border-color: #666;
        }

        .filter-btn.primary {
            background: #4a5568;
            border-color: #718096;
        }

        .filter-btn.primary:hover {
            background: rgba(185, 187, 190, 0.15);
        }

        @media (max-width: 768px) {
            .sidebar {
                position: relative;
                width: 100%;
                max-height: none;
            }

            .main-layout {
                flex-direction: column;
            }

            .footer {
                margin-left: 0;
            }

            .container {
                margin: 0;
                border: none;
            }

            body {
                padding: 0;
            }

            .fullscreen-btn {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }

            .map-symbol {
                width: 30px;
                height: 30px;
            }

            .map-symbol-label {
                font-size: 8px;
                padding: 1px 3px;
            }
        }

        .presentation-load-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-section);
        }

        .presentation-load-btn {
            background: var(--bg-container);
            border: 1px solid var(--border-primary);
            color: white;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 280px;
            justify-content: center;
        }

        .presentation-load-btn:hover {
            background: rgba(185, 187, 190, 0.15);
        }

        .load-text {
            font-size: 16px;
            letter-spacing: 1px;
        }

        .presentation-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #4f545c;
            border-top: 2px solid #4a5568;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .presentation-load-btn {
                padding: 15px 30px;
                font-size: 16px;
                min-width: 240px;
            }

            .load-icon {
                font-size: 20px;
            }

            .load-text {
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <img src="/static/img/logo2.png" class="header-logo" alt="CVW-17 Logo">
            <div class="title">CVIC MENU</div>
            <div class="subtitle">CARRIER AIR WING 17</div>
        </div>

        <div class="main-layout">
            <div class="sidebar">
                <a href="#" class="nav-link">HOME</a>
                <a href="/reports" class="nav-link">AP STRIKE REPORTS</a>
                <a href="/dmpi_db" class="nav-link">DMPI DATABASE</a>
                <a href="/viewer" class="nav-link">DATA VIEWER</a>
                <a href="/tacview" class="nav-link">TACVIEW</a>
                <a href="/tracks" class="nav-link">REPLAYS</a>
                <a href="https://virtualcvw17.com/" class="nav-link">CVW-17 WEBSITE</a>
                <a href="/planmsn" class="nav-link">PLANNING MIZ</a>
            </div>

            <div class="main-content">
                <div class="content">
                    <div class="content-title">STRATEGIC AIR CAMPAIGN TARGETS</div>
                    <div class="divider"></div>

                    <div class="map-container" id="mapContainer">
                        <img class="map-img" id="mapImage" src="/static/maps/interactive_map_z1.jpg" alt="Interactive Map">

                        <div class="map-symbols" id="mapSymbols">
                            {% if drawables %}
                                {% for drawable_id, drawable_data in drawables.items() %}
                                    {% if drawable_data and drawable_data.draw %}
                                        <!-- Generate one ring element per drawable with coordinate data only -->
                                        {% if drawable_data.draw.render_ring and drawable_data.draw.radius_px > 0 and not drawable_data.collision %}
                                            <div class="map-ring hidden {% if drawable_data.draw.type == "BLUE" %}blue{% endif %}"
                                                 data-type="{{ drawable_data.draw.type or '' }}"
                                                 data-x="{{ drawable_data.draw.x }}"
                                                 data-y="{{ drawable_data.draw.y }}"
                                                 data-radius-px="{{ drawable_data.draw.radius_px }}">
                                            </div>
                                        {% endif %}

                                        <!-- Generate one symbol element per drawable with coordinate data only -->
                                        {% if drawable_data.draw.render_icon %}
                                            <img class="map-symbol hidden {% if not drawable_data.collision and drawable_data.package_url %}package{% endif %} {% if drawable_data.collision %}collision{% endif %} {% if drawable_data.aim_points and drawable_data.aim_points["01"].debrief_id %}clickable{% endif %} {% if drawable_data.collision and drawable_data.aim_points and not drawable_data.aim_points["01"].debrief_id %}collision-no-report{% endif %}"
                                                 data-id="{{ drawable_id }}"
                                                 src="{{ drawable_data.draw.symbol }}"
                                                 data-comment="{{ drawable_data.comment or '' }}"
                                                 data-type="{{ drawable_data.draw.type or '' }}"
                                                 data-bda="{{ drawable_data.aim_points["01"].bda}}"
                                                 data-debrief-id="{{ drawable_data.aim_points["01"].debrief_id}}"
                                                 data-lat="{{ drawable_data.aim_points and drawable_data.aim_points["01"] and drawable_data.aim_points["01"].lat or '' }}"
                                                 data-lon="{{ drawable_data.aim_points and drawable_data.aim_points["01"] and drawable_data.aim_points["01"].lon or '' }}"
                                                 {% if drawable_data.heading %}data-brc="{{ drawable_data.draw.heading }}"{% endif %}
                                                 {% if drawable_data.package_url %}data-package-url="{{ drawable_data.package_url }}"{% endif %}
                                                 data-x="{{ drawable_data.draw.x }}"
                                                 data-y="{{ drawable_data.draw.y }}"
                                                 data-radius-px="{{ drawable_data.draw.radius_px }}">
                                        {% endif %}
                                    {% endif %}
                                {% endfor %}
                            {% endif %}
                        </div>

                        <div class="map-controls">
                            <button class="fullscreen-btn" id="downloadBtn" title="Download Image">⬇</button>
                            <button class="fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen">⛶</button>
                            <button class="zoom-btn" id="zoomIn" title="Zoom In">+</button>
                            <button class="zoom-btn" id="zoomOut" title="Zoom Out">−</button>
                            <button class="zoom-btn" id="resetZoom" title="Reset Zoom">⌂</button>
                        </div>
                        <div class="zoom-level" id="zoomLevel">100%</div>

                        <div class="symbol-tooltip" id="symbolTooltip"></div>
                    </div>

                    <div class="map-selector">
                        <button class="map-selector-btn active" id="airDefenceBtn" data-map="z1" data-filter="SAD">AIR DEFENCES</button>
                        <button class="map-selector-btn" id="superMezBtn" data-map="z2" data-filter="SAD">SUPER MEZ</button>
                        <button class="map-selector-btn" id="strategicBtn" data-map="z1" data-filter="strategic">DMPIS</button>
                        <button class="map-selector-btn" id="blueforBtn" data-map="bluefor" data-filter="SAD">BLUEFOR</button>
                    </div>

                    <div class="strategic-filters" id="strategicFilters" style="display: none;">
                        <div class="filter-title">SELECT TARGET TYPES:</div>
                        <div class="filter-grid">
                            <label class="filter-checkbox">
                                <input type="checkbox" value="SAD">
                                <span>SAD</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="C" checked>
                                <span>C</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="L" checked>
                                <span>L</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="CCC" checked>
                                <span>CCC</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="E" checked>
                                <span>E</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="O" checked>
                                <span>O</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="RR" checked>
                                <span>RR</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="A" checked>
                                <span>A</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="N" checked>
                                <span>N</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="MS" checked>
                                <span>MS</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="SC" checked>
                                <span>SC</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" value="RG" checked>
                                <span>RG</span>
                            </label>
                        </div>
                    </div>

                    <div class="content-title" style="margin-top: 40px">DEPLOYMENT PRESENTATION</div>
                    <div class="divider"></div>

                    <div class="presentation-container" id="presentationContainer">
                        <div class="presentation-load-wrapper" id="presentationLoadWrapper">
                            <button class="presentation-load-btn" id="loadPresentationBtn">
                                <span class="load-text">LOAD PRESENTATION</span>
                            </button>
                        </div>
                    </div>

                    <div class="content-title" style="margin-top: 40px;">LATEST BDA</div>
                    <div class="divider"></div>

                    <div class="bda-grid">
                        {% for bda in bdas if bda['img-src'] %}
                            <a href="/debrief/{{ bda['id'] }}" class="bda-card-link">
                                <div class="bda-card">
                                    <div class="bda-weapon">{{ bda['weapon'] }}</div>
                                    <div class="bda-target">{{ bda['target'] }}</div>
                                    <div class="bda-result">{{ bda['bda-result'] }}</div>
                                    <img class="bda-img loading"
                                         alt="NO BDA IMG"
                                         src="/static/img/img-placeholder.webp"
                                         data-src="{{ bda['img-src'] }}"
                                         data-index="{{ loop.index0 }}">
                                    <div class="bda-id-info">
                                        <div>{{ bda['msn-nr'] }}</div>
                                        <div>-</div>
                                        <div>{{ bda['callsign'] }}</div>
                                        <div>-</div>
                                        <div>{{ bda['msn-evt'] }}</div>
                                    </div>
                                    <div class="bda-footer-date">{{ bda['date'] }}</div>
                                </div>
                            </a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <img src="/static/img/logo2.png" width="80" height="72" alt="CVW-17 Logo" class="footer-logo">
            <div class="footer-text">
                <div class="title">VIRTUAL CARRIER AIR WING 17</div>
                <div class="subtitle">Not associated with the Department of Defence or any of its components.</div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // ===========================
            // MAP RENDERING ENGINE
            // ===========================

            class MapRenderer {
                constructor() {
                    this.mapContainer = document.getElementById('mapContainer');
                    this.mapImage = document.getElementById('mapImage');
                    this.mapSymbols = document.getElementById('mapSymbols');
                    this.symbolTooltip = document.getElementById('symbolTooltip');
                    this.zoomLevelDisplay = document.getElementById('zoomLevel');

                    // State
                    this.currentZoom = 1;
                    this.translateX = 0;
                    this.translateY = 0;
                    this.isFullscreen = false;
                    this.currentFilter = 'SAD';
                    this.currentPreset = 'airDefence';
                    this.selectedStrategicTypes = ['C', 'L', 'CCC', 'E', 'O', 'RR', 'A', 'N', 'MS', 'SC', 'RG'];
                    this.resizeTimeout = null; // For debouncing resize events

                    // Constants
                    this.LABEL_KEYWORDS = ['KC135MPRS', 'COURSE LINE'];
                    this.minZoom = 1;
                    this.maxZoom = 8;
                    this.zoomStep = 0.2;
                    this.symbolScale = 0.8;

                    // Presets
                    this.MAP_PRESETS = {
                        airDefence: { zoom: 1.5, centerX: 0.08, centerY: 0.45, filter: 'SAD' },
                        superMez: { zoom: 2.9, centerX: 0.22, centerY: 0.47, filter: 'SAD' },
                        strategic: { zoom: 1.5, centerX: 0.08, centerY: 0.45, filter: 'strategic' },
                        bluefor: { zoom: 1, centerX: 0, centerY: 0, filter: 'BLUE' }
                    };

                    this.init();
                }

                init() {
                    this.createSymbolLabels();
                    this.setupEventListeners();

                    if (this.mapImage.complete) {
                        this.onImageLoaded();
                    } else {
                        this.mapImage.addEventListener('load', () => this.onImageLoaded());
                    }
                }

                onImageLoaded() {
                    this.filterAndShowElements();
                    this.repositionElements(); // Position elements first on initial load
                    this.removeHiddenClasses();
                    requestAnimationFrame(() => {
                        this.goToPreset('airDefence', true);
                    });
                }

                // ===========================
                // CORE RENDERING METHODS
                // ===========================

                render() {
                    this.updateImageTransform();
                    this.updateSymbolScaling(); // Only update symbol scaling, not positions
                    this.updateZoomDisplay();
                }

                // Call this only when container size changes, fullscreen, etc.
                repositionElements() {
                    this.positionElements();
                }

                updateSymbolScaling() {
                    // Update symbol scaling without changing positions
                    const symbols = document.querySelectorAll('.map-symbol');
                    symbols.forEach(symbol => {
                        const currentTransform = symbol.style.transform;
                        const translateMatch = currentTransform.match(/translate\([^)]+\)/);
                        const translatePart = translateMatch ? translateMatch[0] : 'translate(-50%, -50%)';
                        let finalScale = this.symbolScale;
                        if (symbol.getAttribute('data-comment') === "COURSE LINE") {
                            finalScale = 0.5*this.symbolScale;
                        }
                        symbol.style.transform = `${translatePart} scale(${finalScale / this.currentZoom})`;
                    });

                    // Update label scaling
                    const labels = document.querySelectorAll('.map-symbol-label');
                    labels.forEach(label => {
                        const symbolId = label.getAttribute('data-symbol-id');
                        const correspondingSymbol = document.querySelector(`[data-id="${symbolId}"]`);

                        if (correspondingSymbol) {
                            const baseSymbolSize = 36;
                            let finalScale = this.symbolScale;
                            if (correspondingSymbol.getAttribute('data-comment') === "COURSE LINE") {
                                finalScale = 0.5*this.symbolScale;
                            }
                            const scaledSymbolSize = (baseSymbolSize * finalScale) / this.currentZoom;
                            const symbolHalfWidth = scaledSymbolSize / 2;
                            const labelScale = 1.3 / this.currentZoom;

                            label.style.transform = `translate(${symbolHalfWidth}px, ${-symbolHalfWidth}px) scale(${labelScale})`;
                        }
                    });

                    // Update ring border width
                    const rings = document.querySelectorAll('.map-ring');
                    rings.forEach(ring => {
                        ring.style.borderWidth = this.isFullscreen ? '2px' : '1px';
                    });
                }

                updateImageTransform() {
                    const transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.currentZoom})`;
                    this.mapImage.style.transform = transform;
                    this.mapSymbols.style.transform = transform;
                }

                positionElements() {
                    const { baseScaleX, baseScaleY, offsetX, offsetY } = this.getDisplayMetrics();

                    // Check if we have valid metrics before positioning
                    if (!baseScaleX || !baseScaleY) {
                        console.warn('Invalid metrics, skipping positioning');
                        return;
                    }

                    this.positionSymbols(baseScaleX, baseScaleY, offsetX, offsetY);
                    this.positionRings(baseScaleX, baseScaleY, offsetX, offsetY);
                    this.positionLabels(baseScaleX, baseScaleY, offsetX, offsetY);
                }

                getDisplayMetrics() {
                    const naturalWidth = this.mapImage.naturalWidth;
                    const naturalHeight = this.mapImage.naturalHeight;

                    if (!naturalWidth || !naturalHeight) {
                        console.warn('Image not loaded yet');
                        return {};
                    }

                    const containerRect = this.mapContainer.getBoundingClientRect();
                    let displayWidth, displayHeight, offsetX = 0, offsetY = 0;

                    if (this.isFullscreen) {
                        displayWidth = containerRect.width;
                        displayHeight = (containerRect.width / naturalWidth) * naturalHeight;
                    } else {
                        // Use the natural display size of the image (before transforms)
                        displayWidth = this.mapImage.offsetWidth;
                        displayHeight = this.mapImage.offsetHeight;

                        // Don't use image rect offset since we're using container transforms
                        // The container handles all positioning via transforms
                        offsetX = 0;
                        offsetY = 0;
                    }

                    // Ensure we have valid dimensions
                    if (!displayWidth || !displayHeight) {
                        console.warn('Invalid display dimensions');
                        return {};
                    }

                    return {
                        baseScaleX: displayWidth / naturalWidth,
                        baseScaleY: displayHeight / naturalHeight,
                        offsetX,
                        offsetY,
                        displayWidth,
                        displayHeight
                    };
                }

                positionSymbols(baseScaleX, baseScaleY, offsetX, offsetY) {
                    const symbols = document.querySelectorAll('.map-symbol');

                    symbols.forEach(symbol => {
                        const dataX = parseFloat(symbol.getAttribute('data-x'));
                        const dataY = parseFloat(symbol.getAttribute('data-y'));

                        // Position relative to container (without zoom/translation - container handles that)
                        const displayX = dataX * baseScaleX + offsetX;
                        const displayY = dataY * baseScaleY + offsetY;

                        symbol.style.left = displayX + 'px';
                        symbol.style.top = displayY + 'px';

                        let finalScale = this.symbolScale;
                        if (symbol.getAttribute('data-comment') === "COURSE LINE") {
                            finalScale = 0.5*this.symbolScale;
                        }
                        symbol.style.transform = `translate(-50%, -50%) scale(${finalScale / this.currentZoom})`;
                        symbol.style.visibility = 'visible';
                    });
                }

                positionRings(baseScaleX, baseScaleY, offsetX, offsetY) {
                    const rings = document.querySelectorAll('.map-ring');

                    rings.forEach(ring => {
                        const dataX = parseFloat(ring.getAttribute('data-x'));
                        const dataY = parseFloat(ring.getAttribute('data-y'));
                        const radius = parseFloat(ring.getAttribute('data-radius-px'));

                        // Position relative to container (without zoom/translation - container handles that)
                        const displayX = dataX * baseScaleX + offsetX;
                        const displayY = dataY * baseScaleY + offsetY;
                        const scaledRadius = radius * baseScaleX;

                        ring.style.left = displayX + 'px';
                        ring.style.top = displayY + 'px';
                        ring.style.width = (scaledRadius * 2) + 'px';
                        ring.style.height = (scaledRadius * 2) + 'px';
                        ring.style.borderWidth = this.isFullscreen ? '2px' : '1px';

                        const scaleRatio = baseScaleX / baseScaleY;
                        ring.style.transform = `translate(-50%, -50%) scaleY(${1/scaleRatio})`;
                        ring.style.visibility = 'visible';
                    });
                }

                positionLabels(baseScaleX, baseScaleY, offsetX, offsetY) {
                    const labels = document.querySelectorAll('.map-symbol-label');

                    labels.forEach(label => {
                        const symbolId = label.getAttribute('data-symbol-id');
                        const correspondingSymbol = document.querySelector(`[data-id="${symbolId}"]`);

                        if (!correspondingSymbol) return;

                        const dataX = parseFloat(correspondingSymbol.getAttribute('data-x'));
                        const dataY = parseFloat(correspondingSymbol.getAttribute('data-y'));

                        // Position relative to container (without zoom/translation - container handles that)
                        const displayX = dataX * baseScaleX + offsetX;
                        const displayY = dataY * baseScaleY + offsetY;

                        // Calculate label positioning relative to symbol
                        const baseSymbolSize = 36;
                        let finalScale = this.symbolScale;
                        if (correspondingSymbol.getAttribute('data-comment') === "COURSE LINE") {
                            finalScale = 0.5*this.symbolScale;
                        }
                        const scaledSymbolSize = (baseSymbolSize * finalScale) / this.currentZoom;
                        const symbolHalfWidth = scaledSymbolSize / 2;
                        const labelScale = 1.3 / this.currentZoom;

                        label.style.left = displayX + 'px';
                        label.style.top = displayY + 'px';
                        label.style.transform = `translate(${symbolHalfWidth}px, ${-symbolHalfWidth}px) scale(${labelScale})`;
                        label.style.visibility = 'visible';
                    });
                }

                updateZoomDisplay() {
                    this.zoomLevelDisplay.textContent = `${Math.round(this.currentZoom * 100)}%`;
                }

                // ===========================
                // FILTERING AND VISIBILITY
                // ===========================
                createSymbolLabels() {
                    // Remove existing labels
                    document.querySelectorAll('.map-symbol-label').forEach(label => label.remove());

                    const symbols = document.querySelectorAll('.map-symbol');
                    symbols.forEach(symbol => {
                        const comment = symbol.getAttribute('data-comment') || '';
                        const dataId = symbol.getAttribute('data-id') || '';

                        const shouldShowLabel = this.LABEL_KEYWORDS.some(keyword =>
                            comment.toUpperCase().includes(keyword.toUpperCase())
                        );

                        if (shouldShowLabel && dataId) {
                            const label = document.createElement('div');
                            label.className = 'map-symbol-label hidden';
                            label.textContent = dataId;
                            label.setAttribute('data-symbol-id', dataId);
                            this.mapSymbols.appendChild(label);
                        }
                    });
                }

                filterAndShowElements() {
                    this.filterSymbols();
                    this.filterRings();
                    this.filterLabels();
                }

                filterSymbols() {
                    const symbols = document.querySelectorAll('.map-symbol');

                    symbols.forEach(symbol => {
                        const symbolComment = symbol.getAttribute('data-comment');
                        let symbolType = symbol.getAttribute('data-type');

                        // Special handling for strategic filter
                        if (this.currentFilter === 'strategic' && symbolComment.includes('EWR')) {
                            symbolType = 'CCC';
                        }

                        const isVisible = this.shouldElementBeVisible(symbolType);
                        symbol.style.display = isVisible ? 'block' : 'none';
                    });
                }

                filterRings() {
                    const rings = document.querySelectorAll('.map-ring');

                    rings.forEach(ring => {
                        const ringType = ring.getAttribute('data-type');
                        const isVisible = this.shouldElementBeVisible(ringType);
                        ring.style.display = isVisible ? 'block' : 'none';
                    });
                }

                filterLabels() {
                    const labels = document.querySelectorAll('.map-symbol-label');

                    labels.forEach(label => {
                        const symbolId = label.getAttribute('data-symbol-id');
                        const correspondingSymbol = document.querySelector(`[data-id="${symbolId}"]`);

                        if (correspondingSymbol) {
                            const symbolStyle = window.getComputedStyle(correspondingSymbol);
                            const symbolVisible = symbolStyle.display !== 'none' && symbolStyle.visibility !== 'hidden';

                            if (symbolVisible) {
                                label.classList.remove('hidden');
                            } else {
                                label.classList.add('hidden');
                            }
                        } else {
                            label.classList.add('hidden');
                        }
                    });
                }

                shouldElementBeVisible(elementType) {
                    if (this.currentFilter === 'strategic') {
                        return this.selectedStrategicTypes.includes(elementType);
                    } else if (this.currentFilter === 'BLUE') {
                        return elementType === 'BLUE' || elementType === 'SAD';
                    } else {
                        return this.currentFilter === '' || elementType === this.currentFilter;
                    }
                }

                removeHiddenClasses() {
                    document.querySelectorAll('.map-symbol, .map-ring, .map-symbol-label').forEach(element => {
                        element.classList.remove('hidden');
                    });
                }

                // ===========================
                // ZOOM AND NAVIGATION
                // ===========================

                zoomIn() {
                    if (this.currentZoom < this.maxZoom) {
                        this.currentZoom = Math.min(this.maxZoom, this.currentZoom + this.zoomStep);
                        this.constrainTranslation();
                    }
                }

                zoomOut() {
                    if (this.currentZoom > this.minZoom) {
                        this.currentZoom = Math.max(this.minZoom, this.currentZoom - this.zoomStep);
                        this.constrainTranslation();
                    }
                }

                resetZoom() {
                    this.currentZoom = 1;
                    this.translateX = 0;
                    this.translateY = 0;
                    this.repositionElements(); // Reposition elements on zoom reset
                    this.render();
                }

                constrainTranslation() {
                    const containerRect = this.mapContainer.getBoundingClientRect();
                    const { displayWidth, displayHeight } = this.getDisplayMetrics();

                    if (!displayWidth || !displayHeight) return;

                    const scaledWidth = displayWidth * this.currentZoom;
                    const scaledHeight = displayHeight * this.currentZoom;

                    // Constrain to bounds
                    this.translateX = Math.max(Math.min(0, this.translateX), -(scaledWidth - containerRect.width));
                    this.translateY = Math.max(Math.min(0, this.translateY), -(scaledHeight - containerRect.height));

                    // Center if smaller than container
                    if (scaledHeight <= containerRect.height) this.translateY = 0;
                    if (scaledWidth <= containerRect.width) this.translateX = 0;
                }

                calculateTranslationFromCenter(centerX, centerY, zoom) {
                    const containerRect = this.mapContainer.getBoundingClientRect();
                    const { displayWidth, displayHeight } = this.getDisplayMetrics();

                    if (!displayWidth || !displayHeight) return { translateX: 0, translateY: 0 };

                    const scaledWidth = displayWidth * zoom;
                    const scaledHeight = displayHeight * zoom;

                    const centerPixelX = scaledWidth * centerX;
                    const centerPixelY = scaledHeight * centerY;

                    return {
                        translateX: -centerPixelX,
                        translateY: (containerRect.height / 2) - centerPixelY
                    };
                }

                goToPreset(presetName, skipBtn = false) {
                    const preset = this.MAP_PRESETS[presetName];
                    if (!preset) return;

                    this.currentZoom = preset.zoom;
                    const translation = this.calculateTranslationFromCenter(preset.centerX, preset.centerY, preset.zoom);
                    this.translateX = translation.translateX;
                    this.translateY = translation.translateY;

                    this.constrainTranslation();
                    this.currentFilter = preset.filter;
                    this.currentPreset = presetName;

                    // Update UI first
                    if (!skipBtn) {
                        document.querySelectorAll('.map-selector-btn').forEach(btn => btn.classList.remove('active'));
                        if (event && event.currentTarget) {
                            event.currentTarget.classList.add('active');
                        }
                    }

                    const strategicFilters = document.getElementById('strategicFilters');
                    strategicFilters.style.display = presetName === 'strategic' ? 'block' : 'none';

                    // Check if this is initial load (elements not positioned yet)
                    const firstSymbol = document.querySelector('.map-symbol');
                    const isInitialLoad = !firstSymbol || !firstSymbol.style.left;

                    if (isInitialLoad) {
                        // Initial load: filter, position, then render
                        this.filterAndShowElements();
                        this.repositionElements();
                        this.render();
                    } else {
                        // Preset change: render first, then reposition
                        this.render();
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                this.filterAndShowElements();
                                this.repositionElements();
                            });
                        });
                    }
                }

                toggleFullscreen() {
                    this.isFullscreen = !this.isFullscreen;

                    if (this.isFullscreen) {
                        this.mapContainer.classList.add('fullscreen');
                        document.getElementById('fullscreenBtn').title = 'Exit Fullscreen';
                    } else {
                        this.mapContainer.classList.remove('fullscreen');
                        document.getElementById('fullscreenBtn').title = 'Toggle Fullscreen';
                    }

                    // Wait for CSS changes to take effect before repositioning
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            this.goToPreset(this.currentPreset, true);
                        });
                    });
                }

                handleResize() {
                    // Debounce resize events
                    clearTimeout(this.resizeTimeout);
                    this.resizeTimeout = setTimeout(() => {
                        const preset = this.MAP_PRESETS[this.currentPreset];
                        if (preset) {
                            const translation = this.calculateTranslationFromCenter(preset.centerX, preset.centerY, this.currentZoom);
                            this.translateX = translation.translateX;
                            this.translateY = translation.translateY;
                            this.constrainTranslation();

                            requestAnimationFrame(() => {
                                this.repositionElements();
                                this.render();
                            });
                        }
                    }, 100);
                }

                // ===========================
                // EVENT HANDLING
                // ===========================

                setupEventListeners() {
                    this.setupZoomControls();
                    this.setupMapInteraction();
                    this.setupPresetButtons();
                    this.setupFilterControls();
                    this.setupSymbolInteraction();

                    window.addEventListener('resize', () => this.handleResize());

                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && this.isFullscreen) {
                            this.toggleFullscreen();
                        }
                    });
                }

                setupZoomControls() {
                    document.getElementById('zoomIn').addEventListener('click', () => {
                        this.zoomIn();
                        this.render();
                    });

                    document.getElementById('zoomOut').addEventListener('click', () => {
                        this.zoomOut();
                        this.render();
                    });

                    document.getElementById('resetZoom').addEventListener('click', () => {
                        this.resetZoom();
                    });

                    document.getElementById('fullscreenBtn').addEventListener('click', () => {
                        this.toggleFullscreen();
                    });
                }

                setupMapInteraction() {
                    let isDragging = false;
                    let startX = 0;
                    let startY = 0;

                    // Mouse wheel zoom
                    this.mapContainer.addEventListener('wheel', (e) => {
                        e.preventDefault();

                        const rect = this.mapContainer.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        const oldZoom = this.currentZoom;

                        if (e.deltaY < 0) {
                            this.zoomIn();
                        } else {
                            this.zoomOut();
                        }

                        if (this.currentZoom !== oldZoom) {
                            const zoomPointX = mouseX - this.translateX;
                            const zoomPointY = mouseY - this.translateY;
                            const scaleDiff = this.currentZoom - oldZoom;

                            this.translateX -= zoomPointX * scaleDiff / oldZoom;
                            this.translateY -= zoomPointY * scaleDiff / oldZoom;

                            this.constrainTranslation();
                            this.render();
                        }
                    });

                    // Mouse drag
                    this.mapContainer.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startX = e.clientX - this.translateX;
                        startY = e.clientY - this.translateY;
                        this.mapContainer.style.cursor = 'grabbing';
                        e.preventDefault();
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) {
                            this.translateX = e.clientX - startX;
                            this.translateY = e.clientY - startY;
                            this.constrainTranslation();
                            this.render();
                        }
                    });

                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            this.mapContainer.style.cursor = 'grab';
                        }
                    });

                    // Touch handling
                    let lastTouchDistance = 0;

                    this.mapContainer.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) {
                            isDragging = true;
                            startX = e.touches[0].clientX - this.translateX;
                            startY = e.touches[0].clientY - this.translateY;
                        } else if (e.touches.length === 2) {
                            isDragging = false;
                            const touch1 = e.touches[0];
                            const touch2 = e.touches[1];
                            lastTouchDistance = Math.sqrt(
                                Math.pow(touch2.clientX - touch1.clientX, 2) +
                                Math.pow(touch2.clientY - touch1.clientY, 2)
                            );
                        }
                        e.preventDefault();
                    });

                    this.mapContainer.addEventListener('touchmove', (e) => {
                        if (e.touches.length === 1 && isDragging) {
                            this.translateX = e.touches[0].clientX - startX;
                            this.translateY = e.touches[0].clientY - startY;
                            this.constrainTranslation();
                            this.render();
                        } else if (e.touches.length === 2) {
                            const touch1 = e.touches[0];
                            const touch2 = e.touches[1];
                            const currentDistance = Math.sqrt(
                                Math.pow(touch2.clientX - touch1.clientX, 2) +
                                Math.pow(touch2.clientY - touch1.clientY, 2)
                            );

                            if (lastTouchDistance > 0) {
                                const deltaDistance = currentDistance - lastTouchDistance;
                                if (deltaDistance > 0) {
                                    this.currentZoom = Math.min(this.maxZoom, this.currentZoom + this.zoomStep * 0.5);
                                } else {
                                    this.currentZoom = Math.max(this.minZoom, this.currentZoom - this.zoomStep * 0.5);
                                }
                                this.constrainTranslation();
                                this.render();
                            }
                            lastTouchDistance = currentDistance;
                        }
                        e.preventDefault();
                    });

                    this.mapContainer.addEventListener('touchend', () => {
                        isDragging = false;
                        lastTouchDistance = 0;
                    });
                }

                setupPresetButtons() {
                    document.getElementById('airDefenceBtn').addEventListener('click', () => this.goToPreset('airDefence'));
                    document.getElementById('superMezBtn').addEventListener('click', () => this.goToPreset('superMez'));
                    document.getElementById('strategicBtn').addEventListener('click', () => this.goToPreset('strategic'));
                    document.getElementById('blueforBtn').addEventListener('click', () => this.goToPreset('bluefor'));
                }

                setupFilterControls() {
                    const strategicFilters = document.getElementById('strategicFilters');
                    const checkboxes = strategicFilters.querySelectorAll('input[type="checkbox"]');

                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', () => {
                            this.updateSelectedStrategicTypes();
                            this.filterAndShowElements();
                        });
                    });
                }

                updateSelectedStrategicTypes() {
                    const strategicFilters = document.getElementById('strategicFilters');
                    const checkboxes = strategicFilters.querySelectorAll('input[type="checkbox"]:checked');
                    this.selectedStrategicTypes = Array.from(checkboxes).map(cb => cb.value);
                }

                setupSymbolInteraction() {
                    document.querySelectorAll('.map-symbol').forEach(symbol => {
                        symbol.addEventListener('mouseenter', (e) => this.showTooltip(symbol, e));
                        symbol.addEventListener('mouseleave', () => this.hideTooltip());
                        symbol.addEventListener('mousemove', (e) => this.updateTooltipPosition(e));
                        symbol.addEventListener('mousedown', (e) => this.handleSymbolClick(symbol, e));
                        symbol.addEventListener('auxclick', (e) => this.handleSymbolAuxClick(symbol, e));
                    });
                }

                showTooltip(symbol, e) {
                    const id = symbol.getAttribute('data-id');
                    const comment = symbol.getAttribute('data-comment');
                    const lat = symbol.getAttribute('data-lat');
                    const lon = symbol.getAttribute('data-lon');
                    const brc = symbol.getAttribute('data-brc');
                    const bda = symbol.getAttribute('data-bda');
                    const type = symbol.getAttribute('data-type');
                    const debriefId = symbol.getAttribute('data-debrief-id');
                    const packageUrl = symbol.getAttribute('data-package-url');

                    let tooltipContent = '';
                    const displayText = comment || id;
                    tooltipContent += `<div class="tooltip-comment">${displayText}</div>`;

                    if (displayText === comment) {
                        tooltipContent += `<div class="tooltip-comment">${type !== 'BLUE' ? id + '-01' : id}</div>`;
                    }

                    if (bda && bda !== 'None' && bda !== '') {
                        tooltipContent += `<div style="color: #90cdf4; font-weight: bold; margin-bottom: 4px;">BDA: ${bda}</div>`;
                    }

                    if (debriefId && debriefId !== 'None' && debriefId !== '') {
                        tooltipContent += `<div style="color: #98fb98; font-weight: bold; margin-bottom: 4px;">📋 Click for Report</div>`;
                    } else if (packageUrl) {
                        tooltipContent += `<div style="color: #98fb98; font-weight: bold; margin-bottom: 4px;">📋 Click for Target Package</div>`;
                    }

                    if (brc) {
                        tooltipContent += `<div class="tooltip-coords">BRC: ${Math.floor(brc)}°T</div>`;
                    }

                    if (lat && lon) {
                        tooltipContent += `<div class="tooltip-coords">LAT: ${lat}<br>LON: ${lon}</div>`;
                    }

                    this.symbolTooltip.innerHTML = tooltipContent;
                    this.symbolTooltip.classList.add('show');
                    this.updateTooltipPosition(e);
                }

                hideTooltip() {
                    this.symbolTooltip.classList.remove('show');
                }

                updateTooltipPosition(e) {
                    const rect = this.mapContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left + 15;
                    const y = e.clientY - rect.top - 10;

                    this.symbolTooltip.style.left = x + 'px';
                    this.symbolTooltip.style.top = y + 'px';
                }

                handleSymbolClick(symbol, e) {
                    e.stopPropagation();

                    const debriefId = symbol.getAttribute('data-debrief-id');
                    const packageUrl = symbol.getAttribute('data-package-url');

                    let targetUrl = null;
                    if (debriefId && debriefId !== 'None' && debriefId !== '') {
                        targetUrl = `/debrief/${debriefId}`;
                    } else if (packageUrl) {
                        targetUrl = packageUrl;
                    }

                    if (targetUrl) {
                        if (e.button === 1) {
                            e.preventDefault();
                            window.open(targetUrl, '_blank');
                        } else if (e.button === 0) {
                            window.location.href = targetUrl;
                        }
                    }
                }

                handleSymbolAuxClick(symbol, e) {
                    if (e.button === 1) {
                        e.preventDefault();
                        e.stopPropagation();

                        const debriefId = symbol.getAttribute('data-debrief-id');
                        const packageUrl = symbol.getAttribute('data-package-url');

                        let targetUrl = null;
                        if (debriefId && debriefId !== 'None' && debriefId !== '') {
                            targetUrl = `/debrief/${debriefId}`;
                        } else if (packageUrl) {
                            targetUrl = packageUrl;
                        }

                        if (targetUrl) {
                            window.open(targetUrl, '_blank');
                        }
                    }
                }
            }

            // ===========================
            // INITIALIZE MAP RENDERER
            // ===========================

            const mapRenderer = new MapRenderer();

            // ===========================
            // BDA IMAGE LOADING (unchanged)
            // ===========================

            const bdaImages = document.querySelectorAll('.bda-img[data-src]');

            function loadImage(img) {
                const actualSrc = img.getAttribute('data-src');
                if (!actualSrc || actualSrc === '/static/img/img-placeholder.webp') {
                    return;
                }
                if (img.src === actualSrc) {
                    return;
                }

                const tempImg = new Image();
                tempImg.onload = function() {
                    img.src = actualSrc;
                    img.classList.remove('loading');
                    img.classList.add('loaded');
                };
                tempImg.onerror = function() {
                    img.classList.remove('loading');
                };
                tempImg.src = actualSrc;
            }

            function unloadImage(img) {
                const actualSrc = img.getAttribute('data-src');
                if (img.src !== window.location.origin + '/static/img/img-placeholder.webp' &&
                    actualSrc && actualSrc !== '/static/img/img-placeholder.webp') {
                    img.src = '/static/img/img-placeholder.webp';
                    img.classList.add('loading');
                    img.classList.remove('loaded');
                }
            }

            const loadObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        loadImage(img);
                    }
                });
            }, {
                rootMargin: '400px 0px',
                threshold: 0.01
            });

            const unloadObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (!entry.isIntersecting) {
                        const img = entry.target;
                        unloadImage(img);
                    }
                });
            }, {
                rootMargin: '1600px 0px',
                threshold: 0
            });

            bdaImages.forEach(img => {
                loadObserver.observe(img);
                unloadObserver.observe(img);
            });

            // ===========================
            // PRESENTATION LOADING (unchanged)
            // ===========================

            document.getElementById('loadPresentationBtn').addEventListener('click', function() {
                const container = document.getElementById('presentationContainer');
                const loadWrapper = document.getElementById('presentationLoadWrapper');

                loadWrapper.innerHTML = `
                        <div class="presentation-loading">
                            <div class="loading-spinner"></div>
                            <span>Loading presentation...</span>
                        </div>
                    `;

                const iframe = document.createElement('iframe');
                iframe.className = 'presentation-iframe';
                iframe.src = 'https://docs.google.com/presentation/d/e/2PACX-1vQj-u5rSo59uLiGQ7QZNyXvuv4T4xxB5Z9NgLyJNbAfE7vR7mjxe6avClPAfzW1r-ZVFfD4jU75OkLi/pubembed?start=false&loop=false&delayms=3000';
                iframe.frameBorder = '0';
                iframe.allowFullscreen = true;
                iframe.mozAllowFullScreen = true;
                iframe.webkitAllowFullscreen = true;

                iframe.addEventListener('load', function() {
                    setTimeout(() => {
                        if (loadWrapper && loadWrapper.parentNode) {
                            loadWrapper.remove();
                        }
                    }, 500);
                });

                container.appendChild(iframe);
            });

            // ===========================
            // DOWNLOAD FUNCTIONALITY
            // ===========================

            async function captureVisibleArea(symbolSizeMultiplier = 1.0) {
                const mapContainer = document.getElementById('mapContainer');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                const containerRect = mapContainer.getBoundingClientRect();

                const outputWidth = 2550;
                const containerAspect = containerRect.width / containerRect.height;
                const outputHeight = outputWidth / containerAspect;

                const outputScale = outputWidth / containerRect.width;

                canvas.width = outputWidth;
                canvas.height = outputHeight;

                ctx.scale(outputScale, outputScale);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                ctx.fillStyle = '#121212';
                ctx.fillRect(0, 0, containerRect.width, containerRect.height);

                try {
                    const mapImage = document.getElementById('mapImage');
                    const visibleSymbols = Array.from(document.querySelectorAll('.map-symbol'))
                        .filter(symbol => {
                            const style = window.getComputedStyle(symbol);
                            return style.display !== 'none' && style.visibility !== 'hidden';
                        });
                    const visibleRings = Array.from(document.querySelectorAll('.map-ring'))
                        .filter(ring => {
                            const style = window.getComputedStyle(ring);
                            return style.display !== 'none' && style.visibility !== 'hidden';
                        });
                    const visibleLabels = Array.from(document.querySelectorAll('.map-symbol-label'))
                        .filter(label => {
                            const style = window.getComputedStyle(label);
                            return style.display !== 'none' && style.visibility !== 'hidden' && !label.classList.contains('hidden');
                        });

                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = mapImage.src;
                    });

                    const imageRect = mapImage.getBoundingClientRect();

                    let contentX, contentY, contentWidth, contentHeight;

                    if (mapRenderer.isFullscreen) {
                        const naturalWidth = img.naturalWidth;
                        const naturalHeight = img.naturalHeight;
                        const containerWidth = imageRect.width;
                        const containerHeight = imageRect.height;

                        const imageAspect = naturalWidth / naturalHeight;
                        const containerAspect = containerWidth / containerHeight;

                        if (imageAspect > containerAspect) {
                            contentWidth = containerWidth;
                            contentHeight = containerWidth / imageAspect;
                            contentX = 0;
                            contentY = (containerHeight - contentHeight) / 2;
                        } else {
                            contentWidth = containerHeight * imageAspect;
                            contentHeight = containerHeight;
                            contentX = (containerWidth - contentWidth) / 2;
                            contentY = 0;
                        }

                        const relativeX = (imageRect.left - containerRect.left) + contentX;
                        const relativeY = (imageRect.top - containerRect.top) + contentY;
                        ctx.drawImage(img, relativeX, relativeY, contentWidth, contentHeight);
                    } else {
                        const relativeX = imageRect.left - containerRect.left;
                        const relativeY = imageRect.top - containerRect.top;
                        ctx.drawImage(img, relativeX, relativeY, imageRect.width, imageRect.height);
                    }

                    const symbolImages = new Map();
                    const uniqueSrcs = [...new Set(visibleSymbols.map(s => s.src))];

                    await Promise.all(uniqueSrcs.map(src => {
                        return new Promise((resolve) => {
                            if (symbolImages.has(src)) {
                                resolve();
                                return;
                            }
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => {
                                symbolImages.set(src, img);
                                resolve();
                            };
                            img.onerror = () => {
                                console.warn('Failed to load symbol:', src);
                                resolve();
                            };
                            img.src = src;
                        });
                    }));

                    for (const ring of visibleRings) {
                        const ringRect = ring.getBoundingClientRect();

                        const relativeX = ringRect.left - containerRect.left;
                        const relativeY = ringRect.top - containerRect.top;
                        const centerX = relativeX + ringRect.width / 2;
                        const centerY = relativeY + ringRect.height / 2;

                        const actualRadius = ringRect.width / 2;

                        ctx.strokeStyle = window.getComputedStyle(ring).borderColor || '#ff0000';
                        const currentBorderWidth = parseFloat(window.getComputedStyle(ring).borderWidth) || 2;
                        ctx.lineWidth = currentBorderWidth * mapRenderer.currentZoom;

                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, actualRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }

                    for (const symbol of visibleSymbols) {
                        const img = symbolImages.get(symbol.src);
                        if (!img) continue;

                        const symbolRect = symbol.getBoundingClientRect();

                        const relativeX = symbolRect.left - containerRect.left;
                        const relativeY = symbolRect.top - containerRect.top;

                        const originalWidth = symbolRect.width;
                        const originalHeight = symbolRect.height;
                        const scaledWidth = originalWidth * symbolSizeMultiplier;
                        const scaledHeight = originalHeight * symbolSizeMultiplier;

                        const centerX = relativeX + originalWidth / 2;
                        const centerY = relativeY + originalHeight / 2;
                        const scaledX = centerX - scaledWidth / 2;
                        const scaledY = centerY - scaledHeight / 2;

                        ctx.save();

                        if (symbol.classList.contains('collision-no-report')) {
                            ctx.filter = 'grayscale(100%) brightness(0.3)';
                        } else if (symbol.classList.contains('collision')) {
                            ctx.filter = 'grayscale(100%) brightness(1.0)';
                        } else if (symbol.classList.contains('destroyed-no-report')) {
                            ctx.filter = 'brightness(0.4) saturate(0.6)';
                        }

                        ctx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                        ctx.restore();
                    }

                    for (const label of visibleLabels) {
                        // Find the corresponding symbol for this label
                        const symbolId = label.getAttribute('data-symbol-id');
                        const correspondingSymbol = visibleSymbols.find(s => s.getAttribute('data-id') === symbolId);

                        if (!correspondingSymbol) continue;

                        const symbolRect = correspondingSymbol.getBoundingClientRect();

                        // Calculate symbol position and size
                        const symbolRelativeX = symbolRect.left - containerRect.left;
                        const symbolRelativeY = symbolRect.top - containerRect.top;

                        const originalSymbolWidth = symbolRect.width;
                        const originalSymbolHeight = symbolRect.height;
                        const scaledSymbolWidth = originalSymbolWidth * symbolSizeMultiplier;
                        const scaledSymbolHeight = originalSymbolHeight * symbolSizeMultiplier;

                        const symbolCenterX = symbolRelativeX + originalSymbolWidth / 2;
                        const symbolCenterY = symbolRelativeY + originalSymbolHeight / 2;

                        // Calculate scaled symbol bounds
                        const scaledSymbolRight = symbolCenterX + scaledSymbolWidth / 2;
                        const scaledSymbolTop = symbolCenterY - scaledSymbolHeight / 2;

                        // Calculate label height as 75% of symbol height
                        const labelHeight = scaledSymbolHeight * 0.75;
                        const fontSize = labelHeight * 0.6; // Font size as 60% of label height for padding

                        // Set font properties for labels
                        ctx.font = `bold ${fontSize}px monospace`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';

                        // Get text metrics
                        const text = label.textContent;
                        const textMetrics = ctx.measureText(text);

                        // Calculate padding based on label height
                        const verticalPadding = (labelHeight - fontSize) / 2;
                        const horizontalPadding = verticalPadding * 1.2;

                        const backgroundWidth = textMetrics.width + (horizontalPadding * 2);
                        const backgroundHeight = labelHeight;

                        // Position label at right side of symbol, vertically centered
                        const offset = scaledSymbolWidth * 0.05; // 5% offset from symbol edge
                        const labelX = scaledSymbolRight + offset;
                        const labelY = symbolCenterY - (backgroundHeight / 2); // Center vertically with symbol

                        // Draw background
                        ctx.fillStyle = 'rgba(31, 31, 31, 0.95)';
                        ctx.fillRect(labelX, labelY, backgroundWidth, backgroundHeight);

                        // Draw border
                        ctx.strokeStyle = '#4f545c';
                        ctx.lineWidth = Math.max(1 / outputScale, backgroundHeight * 0.02);
                        ctx.strokeRect(labelX, labelY, backgroundWidth, backgroundHeight);

                        // Draw text (centered vertically in the label)
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(text, labelX + horizontalPadding, labelY + backgroundHeight / 2);
                    }

                    // Add watermark
                    const now = new Date();
                    const currentDate = now.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });

                    const currentTime = now.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        timeZone: 'Europe/Berlin'
                    });

                    const isDST = (date) => {
                        const jan = new Date(date.getFullYear(), 0, 1).getTimezoneOffset();
                        const jul = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
                        return Math.max(jan, jul) !== date.getTimezoneOffset();
                    };

                    const timezoneName = isDST(now) ? 'CEST' : 'CET';
                    const missionName = '{{msn}}';

                    const headerText = 'CVW-17 TARGET INTELLIGENCE CELL';
                    const missionText = missionName;
                    const dateTimeText = `${currentDate} ${currentTime} ${timezoneName}`;

                    const baseFontSize = 20;
                    const scaledFontSize = baseFontSize / outputScale;
                    ctx.font = `${scaledFontSize}px Arial, sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';

                    const headerMetrics = ctx.measureText(headerText);
                    const missionMetrics = ctx.measureText(missionText);
                    const dateTimeMetrics = ctx.measureText(dateTimeText);

                    const maxWidth = Math.max(headerMetrics.width, missionMetrics.width, dateTimeMetrics.width);
                    const lineHeight = scaledFontSize * 1.2;
                    const totalHeight = lineHeight * 3;

                    const basePadding = 8;
                    const scaledPadding = basePadding / outputScale;
                    const backgroundWidth = maxWidth + (scaledPadding * 2);
                    const backgroundHeight = totalHeight + (scaledPadding * 2);

                    const baseMargin = 15;
                    const scaledMargin = baseMargin / outputScale;
                    const watermarkX = containerRect.width - scaledMargin;
                    const watermarkY = containerRect.height - scaledMargin;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(
                        watermarkX - backgroundWidth,
                        watermarkY - backgroundHeight,
                        backgroundWidth,
                        backgroundHeight
                    );

                    ctx.fillStyle = '#ffffff';
                    const textStartX = watermarkX - backgroundWidth + scaledPadding;
                    const textStartY = watermarkY - backgroundHeight + scaledPadding;

                    ctx.fillText(headerText, textStartX, textStartY);
                    ctx.fillText(missionText, textStartX, textStartY + lineHeight);
                    ctx.fillText(dateTimeText, textStartX, textStartY + (lineHeight * 2));

                    const link = document.createElement('a');
                    link.download = `interactive-map-${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                } catch (error) {
                    console.error('Manual capture failed:', error);
                    alert('Failed to capture image. Please try again.');
                }
            }

            const downloadBtn = document.getElementById('downloadBtn');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', async function() {
                    try {
                        if (!mapRenderer.isFullscreen)
                            await captureVisibleArea(0.6);
                        else
                            await captureVisibleArea(1.2);
                    } catch (error) {
                        console.error('Canvas capture failed:', error);
                        alert('Failed to capture image. Please try again.');
                    }
                });
            }
        });
    </script>
</body>
</html>